/**
 * Integration tests for unified groupId architecture
 * Feature 070: 統一持倉 groupId 架構
 * (Previously: Feature 069 backward compatibility tests)
 *
 * @vitest-environment node
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createPrismaClient } from '@/lib/prisma-factory';
import { PositionGroupService } from '@/services/trading/PositionGroupService';
import type { PrismaClient } from '@/generated/prisma/client';

// Skip if not running integration tests
const RUN_INTEGRATION = process.env.RUN_INTEGRATION_TESTS === 'true';

// UUID v4 pattern for validation
const UUID_PATTERN = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

/**
 * Helper to create a test position with all required fields
 * Feature 070: groupId is auto-generated if not provided
 */
async function createTestPosition(
  prisma: PrismaClient,
  userId: string,
  overrides: {
    groupId?: string;
    symbol?: string;
    status?: string;
    leverage?: number;
  } = {}
) {
  const now = new Date();

  // Build data - groupId will be auto-generated by database if not provided
  const data: any = {
    userId,
    symbol: overrides.symbol || 'BTCUSDT',
    longExchange: 'binance',
    shortExchange: 'okx',
    longLeverage: overrides.leverage || 10,
    shortLeverage: overrides.leverage || 10,
    longEntryPrice: '50000',
    shortEntryPrice: '50100',
    longPositionSize: '0.01',
    shortPositionSize: '0.01',
    openFundingRateLong: '0.0001',
    openFundingRateShort: '-0.0001',
    status: (overrides.status as any) || 'OPEN',
    conditionalOrderStatus: 'PENDING',
    createdAt: now,
    updatedAt: now,
  };

  // Only add groupId if explicitly provided
  if (overrides.groupId !== undefined) {
    data.groupId = overrides.groupId;
  }

  return prisma.position.create({ data });
}

describe.skipIf(!RUN_INTEGRATION)(
  'Unified groupId Architecture [Feature 070]',
  () => {
    let prisma: PrismaClient;
    let testUserId: string;

    beforeEach(async () => {
      prisma = createPrismaClient();

      // Create test user
      const user = await prisma.user.create({
        data: {
          email: `test-unified-${Date.now()}-${Math.random().toString(36).slice(2)}@example.com`,
          password: 'test-password-hash',
        },
      });
      testUserId = user.id;
    });

    afterEach(async () => {
      // Clean up test positions first (due to FK constraint)
      await prisma.position.deleteMany({
        where: { userId: testUserId },
      });
      // Clean up test user
      await prisma.user.delete({
        where: { id: testUserId },
      });
      await prisma.$disconnect();
    });

    describe('All positions have groupId', () => {
      it('should auto-generate groupId for single positions', async () => {
        // Create a position without explicit groupId
        const position = await createTestPosition(prisma, testUserId, {
          symbol: 'BTCUSDT',
        });

        // Should have a valid UUID groupId
        expect(position.groupId).not.toBeNull();
        expect(position.groupId).toMatch(UUID_PATTERN);
      });

      it('should create unique groupId for each single position', async () => {
        // Create multiple positions without explicit groupId
        const pos1 = await createTestPosition(prisma, testUserId, {
          symbol: 'BTCUSDT',
        });
        const pos2 = await createTestPosition(prisma, testUserId, {
          symbol: 'ETHUSDT',
        });

        // Each should have its own unique groupId
        expect(pos1.groupId).not.toBeNull();
        expect(pos2.groupId).not.toBeNull();
        expect(pos1.groupId).not.toBe(pos2.groupId);
      });

      it('should preserve explicit groupId for split positions', async () => {
        // Create positions with explicit shared groupId (split open)
        const groupId = PositionGroupService.generateGroupId();

        const pos1 = await createTestPosition(prisma, testUserId, {
          groupId,
          symbol: 'BTCUSDT',
        });
        const pos2 = await createTestPosition(prisma, testUserId, {
          groupId,
          symbol: 'BTCUSDT',
        });

        // Both should share the same groupId
        expect(pos1.groupId).toBe(groupId);
        expect(pos2.groupId).toBe(groupId);
      });
    });

    describe('PositionGroupService with unified groupId', () => {
      it('should return all positions in groups array', async () => {
        // Create single positions (auto-generated groupId)
        await createTestPosition(prisma, testUserId, { symbol: 'BTCUSDT' });
        await createTestPosition(prisma, testUserId, { symbol: 'ETHUSDT' });

        // Create split positions (shared groupId)
        const groupId = PositionGroupService.generateGroupId();
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'XRPUSDT' });
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'XRPUSDT' });

        const groupService = new PositionGroupService(prisma);
        const result = await groupService.getPositionsGrouped(testUserId, 'OPEN');

        // Feature 070: No more positions array, only groups
        expect((result as any).positions).toBeUndefined();

        // Should have 3 groups: 2 single + 1 split
        expect(result.groups.length).toBe(3);

        // Find the split group
        const splitGroup = result.groups.find(g => g.groupId === groupId);
        expect(splitGroup).toBeDefined();
        expect(splitGroup!.positions.length).toBe(2);

        // Single position groups should have 1 position each
        const singleGroups = result.groups.filter(g => g.groupId !== groupId);
        expect(singleGroups.length).toBe(2);
        singleGroups.forEach(g => {
          expect(g.positions.length).toBe(1);
          expect(g.aggregate.positionCount).toBe(1);
        });
      });

      it('should correctly aggregate single position groups', async () => {
        // Create a single position
        await createTestPosition(prisma, testUserId, { symbol: 'BTCUSDT' });

        const groupService = new PositionGroupService(prisma);
        const result = await groupService.getPositionsGrouped(testUserId, 'OPEN');

        expect(result.groups.length).toBe(1);
        expect(result.groups[0].aggregate.positionCount).toBe(1);
        expect(result.groups[0].positions.length).toBe(1);
      });
    });

    describe('Close operations with unified groupId', () => {
      it('should close single position normally', async () => {
        // Create a single position
        const position = await createTestPosition(prisma, testUserId, {
          status: 'OPEN',
        });

        // Close the position
        const closedPosition = await prisma.position.update({
          where: { id: position.id },
          data: {
            status: 'CLOSED',
            closeReason: 'MANUAL',
            closedAt: new Date(),
          },
        });

        expect(closedPosition.status).toBe('CLOSED');
        expect(closedPosition.closeReason).toBe('MANUAL');
        // Feature 070: groupId should still be present
        expect(closedPosition.groupId).not.toBeNull();
        expect(closedPosition.groupId).toMatch(UUID_PATTERN);
      });

      it('should batch close split positions without affecting single positions', async () => {
        // Create a single position
        const singlePosition = await createTestPosition(prisma, testUserId, {
          symbol: 'ETHUSDT',
        });

        // Create split positions
        const groupId = PositionGroupService.generateGroupId();
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'BTCUSDT' });
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'BTCUSDT' });

        // Batch close split positions
        await prisma.position.updateMany({
          where: { groupId, status: 'OPEN' },
          data: {
            status: 'CLOSED',
            closeReason: 'BATCH_CLOSE',
            closedAt: new Date(),
          },
        });

        // Verify single position is still open
        const stillOpen = await prisma.position.findUnique({
          where: { id: singlePosition.id },
        });
        expect(stillOpen).not.toBeNull();
        expect(stillOpen!.status).toBe('OPEN');
        // Feature 070: groupId should be present
        expect(stillOpen!.groupId).not.toBeNull();

        // Verify split positions are closed
        const closedPositions = await prisma.position.findMany({
          where: { groupId, status: 'CLOSED' },
        });
        expect(closedPositions.length).toBe(2);
        expect(closedPositions.every((p) => p.closeReason === 'BATCH_CLOSE')).toBe(true);
      });
    });

    describe('Edge cases', () => {
      it('should handle empty results gracefully', async () => {
        const groupService = new PositionGroupService(prisma);
        const result = await groupService.getPositionsGrouped(testUserId, 'OPEN');

        expect(result.groups).toEqual([]);
      });

      it('should handle all single positions (no split groups)', async () => {
        // Create only single positions
        await createTestPosition(prisma, testUserId, { symbol: 'BTCUSDT' });
        await createTestPosition(prisma, testUserId, { symbol: 'ETHUSDT' });
        await createTestPosition(prisma, testUserId, { symbol: 'XRPUSDT' });

        const groupService = new PositionGroupService(prisma);
        const result = await groupService.getPositionsGrouped(testUserId, 'OPEN');

        // Feature 070: All in groups, each with 1 position
        expect(result.groups.length).toBe(3);
        result.groups.forEach(g => {
          expect(g.positions.length).toBe(1);
        });
      });

      it('should handle all split positions (no single positions)', async () => {
        // Create only split positions
        const groupId = PositionGroupService.generateGroupId();
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'BTCUSDT' });
        await createTestPosition(prisma, testUserId, { groupId, symbol: 'BTCUSDT' });

        const groupService = new PositionGroupService(prisma);
        const result = await groupService.getPositionsGrouped(testUserId, 'OPEN');

        expect(result.groups.length).toBe(1);
        expect(result.groups[0].positions.length).toBe(2);
      });
    });
  }
);
